{"version":3,"sources":["../../src/build/lockfile.ts"],"sourcesContent":["import { bold, cyan } from '../lib/picocolors'\nimport * as Log from './output/log'\n\nimport type { Binding, Lockfile as NativeLockfile } from './swc/types'\n\nconst RETRY_DELAY_MS = 10\nconst MAX_RETRY_MS = 1000\n\n/**\n * A cross-platform on-disk best-effort advisory exclusive lockfile\n * implementation.\n *\n * On Windows, this opens a file in write mode with the `FILE_SHARE_WRITE` flag\n * unset, so it still allows reading the lockfile. This avoids breaking tools\n * that read the contents of `.next`.\n *\n * On POSIX platforms, this uses `flock()` via `std::fs::File::try_lock`:\n * https://doc.rust-lang.org/std/fs/struct.File.html#method.try_lock\n *\n * On WASM, a dummy implementation is used which always \"succeeds\" in acquiring\n * the lock.\n *\n * This provides a more idiomatic wrapper around the lockfile APIs exposed on\n * the native bindings object.\n *\n * If this lock is not explicitly closed with `unlock`, we will:\n * - If `unlockOnExit` is set (the default), it will make a best-effort attempt\n *   to unlock the lockfile using `process.on('exit', ...)`. This is preferrable\n *   on Windows where it may take some time after process exit for the operating\n *   system to clean up locks that are not explicitly released by the process.\n * - If we fail to ever release the lockfile, the operating system will clean up\n *   the lock and file descriptor upon process exit.\n */\nexport class Lockfile {\n  /**\n   * The underlying `Lockfile` object returned by the native bindings.\n   *\n   * This can be `undefined` on wasm, where we don't acquire a real lockfile.\n   */\n  private bindings: Binding\n  private nativeLockfile: NativeLockfile | undefined\n  private listener: NodeJS.ExitListener | undefined\n\n  private constructor(\n    bindings: Binding,\n    nativeLockfile: NativeLockfile | undefined\n  ) {\n    this.bindings = bindings\n    this.nativeLockfile = nativeLockfile\n  }\n\n  /**\n   * Attempts to create or acquire an exclusive lockfile on disk. Lockfiles are\n   * best-effort, depending on the platform.\n   *\n   * - If we fail to acquire the lock, we return `undefined`.\n   * - If we're on wasm, this always returns a dummy `Lockfile` object.\n   */\n  static async tryAcquire(\n    path: string,\n    unlockOnExit: boolean = true\n  ): Promise<Lockfile | undefined> {\n    const { loadBindings } = require('./swc') as typeof import('./swc')\n    // Ideally we could provide a sync version of `tryAcquire`, but\n    // `loadBindings` is async. We're okay with skipping async-loaded wasm\n    // bindings and the internal `loadNative` function is synchronous, but it\n    // lacks some checks that `loadBindings` has.\n    const bindings = await loadBindings()\n    if (bindings.isWasm) {\n      Log.info(\n        `Skipping creating a lockfile at ${cyan(path)} because we're using WASM bindings`\n      )\n      return new Lockfile(bindings, undefined)\n    } else {\n      let nativeLockfile\n      try {\n        nativeLockfile = await bindings.lockfileTryAcquire(path)\n      } catch (e) {\n        // this happens if there's an IO error (e.g. `ENOENT`), which is\n        // different than if we just didn't acquire the lock\n        throw new Error(\n          'An IO error occurred while attempting to create and acquire the lockfile',\n          { cause: e }\n        )\n      }\n      if (nativeLockfile != null) {\n        const jsLockfile = new Lockfile(bindings, nativeLockfile)\n        if (unlockOnExit) {\n          const exitListener = () => {\n            // Best-Effort: If we don't do this, the operating system will\n            // release the lock for us. This gives an opportunity to delete the\n            // unlocked lockfile (which is not otherwise deleted on POSIX).\n            //\n            // This must be synchronous because `process.on('exit', ...)` is\n            // synchronous.\n            jsLockfile.unlockSync()\n          }\n          process.on('exit', exitListener)\n          jsLockfile.listener = exitListener\n        }\n        return jsLockfile\n      } else {\n        return undefined\n      }\n    }\n  }\n\n  /**\n   * Attempts to create or acquire a lockfile using `Lockfile.tryAcquire`. If\n   * that returns `undefined`, indicating that another process or caller has the\n   * lockfile, then this will output an error message and exit the process with\n   * a non-zero exit code.\n   *\n   * This will retry a small number of times. This can be useful when running\n   * processes in a loop, e.g. if cleanup isn't fully synchronous due to child\n   * parent/processes.\n   */\n  static async acquireWithRetriesOrExit(\n    path: string,\n    processName: string,\n    unlockOnExit: boolean = true\n  ): Promise<Lockfile> {\n    const startMs = Date.now()\n    let lockfile\n    while (Date.now() - startMs < MAX_RETRY_MS) {\n      lockfile = await Lockfile.tryAcquire(path, unlockOnExit)\n      if (lockfile !== undefined) break\n      await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS))\n    }\n    if (lockfile === undefined) {\n      Log.error(\n        `Unable to acquire lock at ${cyan(path)}, is another instance of ${cyan(processName)} running?`\n      )\n      Log.info(\n        `${bold('Suggestion:')} If you intended to restart ${cyan(processName)}, terminate the other process, and then try again.`\n      )\n      process.exit(1)\n    }\n    return lockfile\n  }\n\n  /**\n   * Releases the lockfile and closes the file descriptor.\n   *\n   * If this is not called, the lock will be released by the operating system\n   * when the file handle is closed during process exit.\n   */\n  async unlock(): Promise<void> {\n    const { nativeLockfile, listener } = this\n    if (nativeLockfile !== undefined) {\n      await this.bindings.lockfileUnlock(nativeLockfile)\n    }\n    if (listener !== undefined) {\n      process.off('exit', listener)\n    }\n  }\n\n  /**\n   * A blocking version of `unlock`.\n   */\n  unlockSync(): void {\n    const { nativeLockfile, listener } = this\n    if (nativeLockfile !== undefined) {\n      this.bindings.lockfileUnlockSync(nativeLockfile)\n    }\n    if (listener !== undefined) {\n      process.off('exit', listener)\n    }\n  }\n}\n"],"names":["bold","cyan","Log","RETRY_DELAY_MS","MAX_RETRY_MS","Lockfile","bindings","nativeLockfile","tryAcquire","path","unlockOnExit","loadBindings","require","isWasm","info","undefined","lockfileTryAcquire","e","Error","cause","jsLockfile","exitListener","unlockSync","process","on","listener","acquireWithRetriesOrExit","processName","startMs","Date","now","lockfile","Promise","resolve","setTimeout","error","exit","unlock","lockfileUnlock","off","lockfileUnlockSync"],"mappings":"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","ignoreList":[0]}